<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js + D3.js Interactive Visualization</title>

    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Three.js (ESM version) -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
    }
    </script>

    <style>
        body {
            margin: 0;
            font-family: system-ui, sans-serif;
            background-color: #f9f9f9;
        }

        #three-container {
            width: 100%;
            height: 700px;
            background: #22147eff;
            display: block;
        }

        #graph-container {
            width: 100%;
            height: 400px;
            margin-top: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        svg {
            width: 90%;
            height: 100%;
        }

        #slider-container {
            width: 80%;
            margin: 20px auto;
            text-align: center;
        }

        input[type="range"] {
            width: 100%;
        }

        #year-label {
            font-weight: bold;
        }
    </style>
</head>
<body>

    <!-- 3D Scene -->
    <div id="three-container"></div>

    <!-- Graph -->
    <div id="graph-container">
        <svg id="graph"></svg>
    </div>

    <!-- Slider -->
    <div id="slider-container">
        <label for="year-slider">Year: <span id="year-label">2000</span></label>
        <input type="range" id="year-slider" min="1979" max="2023" value="1979" step="1">
    </div>

    <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

    // =========================
    // THREE.JS ENVIRONMENT
    // =========================
    const threeContainer = document.getElementById('three-container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, threeContainer.clientWidth / threeContainer.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    // Use sRGB output so color textures (sRGB) appear correctly on screen
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.setSize(threeContainer.clientWidth, threeContainer.clientHeight);
        threeContainer.appendChild(renderer.domElement);

    const light = new THREE.AmbientLight(0xffffff, 1.2);
    scene.add(light);

    const directLight = new THREE.DirectionalLight(0xffffff, 3.0);
    directLight.position.set(1, 1, 2);
    directLight.castShadow = true;
    scene.add(directLight);

    // Debug helpers to help locate the model while developing
    // const axes = new THREE.AxesHelper(2);
    // scene.add(axes);
    // const grid = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
    // scene.add(grid);

    camera.position.z = 5;

    // Orbit controls to inspect the scene (use mouse/trackpad)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0, 0);
    controls.update();

        // GLTF loader + model storage
    const loader = new GLTFLoader();
    let fishModel = null; // root scene of loaded GLTF
    let fishAnimations = []; // array of AnimationClip from the loaded GLTF
    // Animation mixers for each cloned instance
    let mixers = [];
    const clock = new THREE.Clock();

        // ------- Grouping & Label (Sprite) support -------
        // Number of fish groups. Each group will share the same numeric label texture.
        const numGroups = 3; // change this to however many groups you want
        const groups = []; // each entry: { id, value, material, texture }

        // Helper: create a canvas texture showing a number/string
        function createTextTexture(text, opts = {}) {
            const font = opts.font || '28px Arial';
            const padding = opts.padding || 16;
            const fg = opts.fg || '#ffffff';
            const bg = opts.bg || 'rgba(0,0,0,0.5)';

            // create a canvas sized to the text
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = font;
            const metrics = ctx.measureText(text);
            const textWidth = Math.ceil(metrics.width);
            const textHeight = Math.ceil(parseInt(font, 10));

            canvas.width = textWidth + padding * 2;
            canvas.height = textHeight + padding * 2;

            // draw background
            ctx.fillStyle = bg;
            // rounded rect background
            const r = 8;
            ctx.beginPath();
            ctx.moveTo(r, 0);
            ctx.lineTo(canvas.width - r, 0);
            ctx.quadraticCurveTo(canvas.width, 0, canvas.width, r);
            ctx.lineTo(canvas.width, canvas.height - r);
            ctx.quadraticCurveTo(canvas.width, canvas.height, canvas.width - r, canvas.height);
            ctx.lineTo(r, canvas.height);
            ctx.quadraticCurveTo(0, canvas.height, 0, canvas.height - r);
            ctx.lineTo(0, r);
            ctx.quadraticCurveTo(0, 0, r, 0);
            ctx.closePath();
            ctx.fill();

            // draw text
            ctx.font = font;
            ctx.fillStyle = fg;
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'center';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.needsUpdate = true;

            return { texture, canvas };
        }

        // Initialize group materials (created once and reused). Values can be updated later.
        function initGroups(initialBaseValue = 0) {
            if (groups.length > 0) return; // already initialized
            for (let gi = 0; gi < numGroups; gi++) {
                // compute an initial per-group value; small offset so labels differ
                const factor = 1 + (gi - (numGroups - 1) / 2) * 0.2; // e.g., 0.8,1.0,1.2 for 3 groups
                const val = Math.round(initialBaseValue * factor);
                const { texture } = createTextTexture(String(val + "짜"));
                const material = new THREE.SpriteMaterial({ map: texture, depthTest: false });
                groups.push({ id: gi, value: val, material, texture });
            }
        }

        // Update the displayed text for each group (disposes old texture maps)
        function updateGroupLabels(values) {
            // values: array of strings or numbers of length numGroups
            for (let gi = 0; gi < numGroups; gi++) {
                const g = groups[gi];
                const newText = (gi < values.length) ? String(values[gi]) : String(values[0] || 0);

                // dispose previous texture if present
                if (g.texture && g.texture.dispose) {
                    try { g.texture.dispose(); } catch (e) { /* ignore */ }
                }

                const { texture } = createTextTexture(newText + "짜");
                g.texture = texture;
                // assign new map and mark for update
                g.material.map = texture;
                g.material.needsUpdate = true;
                g.value = newText;
            }
        }

        // load the tuna model (relative to this HTML file)
        loader.load('3DModels/bluefin_tuna_gltf/scene.gltf', gltf => {
            fishModel = gltf.scene;
            fishAnimations = gltf.animations || [];
            // ensure meshes cast/receive shadows and convert materials to unlit so
            // textures are visible without scene lights. We keep important flags
            // (skinning, morph targets, side, transparency) where possible.
            fishModel.traverse(node => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;

                    // Helper to convert a single material to an unlit MeshBasicMaterial
                    const convertToUnlit = (mat) => {
                        if (!mat) return mat;

                        // Preserve the color texture (map) and alpha properties.
                        const params = {
                            color: (mat.color !== undefined) ? mat.color.clone() : undefined,
                            map: mat.map || null,
                            aoMap: null,
                            lightMap: null,
                            transparent: !!mat.transparent,
                            opacity: (mat.opacity !== undefined) ? mat.opacity : 1,
                            alphaTest: mat.alphaTest || 0,
                            side: mat.side || THREE.FrontSide,
                            skinning: mat.skinning || false,
                            morphTargets: mat.morphTargets || false,
                            morphNormals: mat.morphNormals || false,
                        };

                        // If the material already uses a texture, ensure correct color encoding
                        if (params.map) params.map.encoding = THREE.sRGBEncoding;

                        const newMat = new THREE.MeshBasicMaterial(params);
                        // Keep name for debugging
                        newMat.name = (mat.name ? mat.name + " (unlit)" : "unlit-material");
                        newMat.needsUpdate = true;
                        return newMat;
                    };

                    if (Array.isArray(node.material)) {
                        node.material = node.material.map(m => convertToUnlit(m));
                    } else {
                        node.material = convertToUnlit(node.material);
                    }
                }
            });
            // adjust model scale/rotation if needed
            fishModel.scale.set(0.02, 0.02, 0.02);
            fishModel.rotation.y = Math.PI; // small orientation fix if needed

            // Compute bounding box and center the model at the origin so instances appear where expected
            const bbox = new THREE.Box3().setFromObject(fishModel);
            const size = bbox.getSize(new THREE.Vector3());
            const center = bbox.getCenter(new THREE.Vector3());
            console.log('Loaded model bbox size:', size, 'center:', center);
            // Move the model so its center is at the origin
            fishModel.position.sub(center);

            // Reposition camera to fit model nicely (simple framing)
            const maxDim = Math.max(size.x, size.y, size.z);
            const fitDist = maxDim * 2.0 + 2.0;
            camera.position.set(0, maxDim * 0.5, fitDist);
            camera.near = 0.1;
            camera.far = Math.max(1000, fitDist * 10);
            camera.updateProjectionMatrix();
            controls.target.set(0, 0, 0);
            controls.update();

            // If slider exists already, refresh visualization to show the loaded model
            const s = document.getElementById('year-slider');
            if (s) updateVisualization(+s.value);
        }, undefined, err => {
            console.error('Error loading GLTF model:', err);
        });

        let cubes = [];
        // per-fish runtime state: { wrapper, velocity: THREE.Vector3, speed: Number }
        let fishData = [];

        // bounds where fishes are allowed to swim (centered at origin)
        const swimBounds = {
            x: [-10, 10],
            y: [-5, 5],
            z: [-10, 10]
        };

        // orientation flip to correct model facing (applied after lookAt)
        const spawnFlipY = Math.PI; // 180째 around Y

        function clearCubes() {
            cubes.forEach(cube => scene.remove(cube));
            cubes = [];
            // Stop and clear any animation mixers for the removed instances
            mixers.forEach(m => {
                try {
                    m.stopAllAction();
                } catch (e) {
                    // ignore errors during cleanup
                }
            });
            mixers = [];
            // clear per-fish runtime data
            fishData = [];
        }

        // createCubes now instantiates clones of the loaded GLTF root scene
        // Falls back to a box mesh while the model is still loading
        function createCubes(count) {
            clearCubes();

            // ensure groups exist (use 0 as base if no data yet)
            initGroups(0);

            // create each instance at a random position within swimBounds and give it a random velocity
            for (let i = 0; i < count; i++) {
                let instance;
                const wrapper = new THREE.Object3D();

                if (fishModel) {
                    // Properly clone GLTF scenes (handles skinned meshes / skeletons)
                    instance = SkeletonUtils.clone(fishModel);
                    instance.position.set(0, 0, 0);
                    wrapper.add(instance);

                    // If the original GLTF had animations, create a mixer for this clone and play the first clip
                    if (fishAnimations && fishAnimations.length > 0) {
                        const mixer = new THREE.AnimationMixer(instance);
                        const clip = fishAnimations[0];
                        try {
                            const action = mixer.clipAction(clip);
                            action.reset();
                            action.play();
                        } catch (e) {
                            console.warn('Could not create animation action for clone:', e);
                        }
                        mixers.push(mixer);
                    }
                } else {
                    // fallback box while model loads
                    const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                    const material = new THREE.MeshBasicMaterial({ color: 0x0077ff });
                    instance = new THREE.Mesh(geometry, material);
                    wrapper.add(instance);
                }

                // random starting position inside bounds
                const px = swimBounds.x[0] + Math.random() * (swimBounds.x[1] - swimBounds.x[0]);
                const py = swimBounds.y[0] + Math.random() * (swimBounds.y[1] - swimBounds.y[0]);
                const pz = swimBounds.z[0] + Math.random() * (swimBounds.z[1] - swimBounds.z[0]);
                wrapper.position.set(px, py, pz);

                // small random initial rotation so they don't all face the same direction
                wrapper.rotation.y = Math.random() * Math.PI * 2;

                scene.add(wrapper);
                cubes.push(wrapper);

                // assign a random velocity and speed
                // bias movement to be more parallel to the X axis (vertical)
                const lateralBias = 0.2; // how much lateral movement (y/z) is allowed relative to Y
                const vx = (Math.random() * 2 - 1); // full variation left/right
                const vy = (Math.random() * 2 - 1) * lateralBias; 
                const vz = (Math.random() * 2 - 1) * lateralBias;
                const vel = new THREE.Vector3(vx, vy, vz).normalize();
                const speed = 0.5 + Math.random() * 1.5; // units per second

                // assign this fish to a group (round-robin distribution)
                const groupIndex = i % numGroups;

                // create and attach a label sprite above the fish using the group's material
                const label = new THREE.Sprite(groups[groupIndex].material);
                // place the sprite above the model (tweak Y offset as needed)
                label.position.set(0, 1.6, 0);
                // scale down/increase to a reasonable size on screen
                label.scale.set(1.4, 0.6, 1);
                // disable depth test so labels are readable on top
                label.material.depthTest = false;
                wrapper.add(label);

                fishData.push({ wrapper, velocity: vel, speed, groupIndex, label });

                if (fishModel) {
                    console.log('Created fish instance', i + 1, 'pos', wrapper.position.toArray());
                } else {
                    console.log('Created fallback box instance', i + 1);
                }
            }

            console.log('Total instances created:', cubes.length);
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Update per-instance animation mixers (if any)
            if (mixers && mixers.length > 0) {
                for (let mi = 0; mi < mixers.length; mi++) {
                    mixers[mi].update(delta);
                }
            }


            // Update fish movement: simple steering inside swimBounds with reflection and orientation
            for (let i = 0; i < fishData.length; i++) {
                const f = fishData[i];
                const w = f.wrapper;
                // move position
                const move = f.velocity.clone().multiplyScalar(f.speed * delta);
                w.position.add(move);

                // if out of bounds on any axis, reflect the velocity component and clamp position
                if (w.position.x < swimBounds.x[0]) {
                    w.position.x = swimBounds.x[0] + (swimBounds.x[0] - w.position.x);
                    f.velocity.x *= -1;
                } else if (w.position.x > swimBounds.x[1]) {
                    w.position.x = swimBounds.x[1] - (w.position.x - swimBounds.x[1]);
                    f.velocity.x *= -1;
                }
                if (w.position.y < swimBounds.y[0]) {
                    w.position.y = swimBounds.y[0] + (swimBounds.y[0] - w.position.y);
                    f.velocity.y *= -1;
                } else if (w.position.y > swimBounds.y[1]) {
                    w.position.y = swimBounds.y[1] - (w.position.y - swimBounds.y[1]);
                    f.velocity.y *= -1;
                }
                if (w.position.z < swimBounds.z[0]) {
                    w.position.z = swimBounds.z[0] + (swimBounds.z[0] - w.position.z);
                    f.velocity.z *= -1;
                } else if (w.position.z > swimBounds.z[1]) {
                    w.position.z = swimBounds.z[1] - (w.position.z - swimBounds.z[1]);
                    f.velocity.z *= -1;
                }

                // small random perturbation so motion looks natural
                const wobble = 0.2 * delta;
                f.velocity.x += (Math.random() * 2 - 1) * wobble;
                f.velocity.y += (Math.random() * 2 - 1) * wobble * 0.3; // less vertical variation
                f.velocity.z += (Math.random() * 2 - 1) * wobble;
                f.velocity.normalize();

                // orient the wrapper to face movement direction
                // make a temporary target ahead of the fish
                const lookTarget = w.position.clone().add(f.velocity);
                w.lookAt(lookTarget);
                // rotate by 180째 around Y so the model faces forward if it was backwards
                w.rotateY(spawnFlipY);

                // Ensure the label always faces the camera by copying camera quaternion
                if (f.label) {
                    // Position label a bit above the fish in world space
                    // (label is parented to wrapper, so local position already offsets above model)
                    // Make the sprite face the camera by matching its quaternion to camera's
                    f.label.quaternion.copy(camera.quaternion);
                }
            }

            // update orbit controls
            if (typeof controls !== 'undefined') controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // =========================
        // D3.JS GRAPH SETUP
        // =========================
        // D3 graph variables (will be initialized after CSV load)
        const svg = d3.select("#graph");
        const width = svg.node().clientWidth;
        const height = svg.node().clientHeight;
        const margin = { top: 20, right: 30, bottom: 30, left: 40 };
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // place-holder group for chart elements; actual content added in buildGraph()
        let xScale, yScale, line, focusCircle, pathElem, xAxisGroup, yAxisGroup, g;

        // CSV data will be stored here after loading and parsing
        let csvData = [];

        // Map each group index to a species name from the CSV header.
        // Adjust this list if you want different species per group.
        const groupSpecies = ['Tuna fish', 'Horse mackerel', 'Sardines', 'Bonito', 'Salmon', 'Mackerel', 'Saury', 'Sea bream', 'Yellowtail', 'Cuttlefish', 'Octopus', 'Prawns', 'Short-necked clams', 'Oysters', 'Scallops'];

        function buildGraph(dataRows) {
            // Build scales and axes based on parsed CSV rows (use first species for y-range)
            g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            xScale = d3.scaleLinear()
                .domain(d3.extent(dataRows, d => d.Year))
                .range([0, innerWidth]);

            // use the first mapped species to determine y domain for the visible line
            const primary = groupSpecies[0];
            yScale = d3.scaleLinear()
                .domain([0, d3.max(dataRows, d => d[primary])])
                .range([innerHeight, 0]);

            line = d3.line()
                .x(d => xScale(d.Year))
                .y(d => yScale(d[primary]));

            pathElem = g.append("path")
                .datum(dataRows)
                .attr("fill", "none")
                .attr("stroke", "#0077ff")
                .attr("stroke-width", 2)
                .attr("d", line);

            xAxisGroup = g.append("g")
                .attr("transform", `translate(0,${innerHeight})`)
                .call(d3.axisBottom(xScale).tickFormat(d3.format("d")));

            yAxisGroup = g.append("g")
                .call(d3.axisLeft(yScale));

            focusCircle = g.append("circle")
                .attr("r", 5)
                .attr("fill", "red")
                .style("opacity", 0);
        }

        // =========================
        // SLIDER INTERACTION
        // =========================
        const slider = document.getElementById('year-slider');
        const yearLabel = document.getElementById('year-label');

        function updateVisualization(year) {
            yearLabel.textContent = year;

            // --- D3 Update ---
            const point = csvData.find(d => d.Year === +year);
            if (point && xScale && yScale) {
                // For the graph we display the primary species (groupSpecies[0])
                focusCircle
                    .attr("cx", xScale(point.Year))
                    .attr("cy", yScale(point[groupSpecies[0]]))
                    .style("opacity", 1);
            }

            // --- Three.js Update ---
            // determine cube count based on full CSV year range
            const minYear = csvData.length ? d3.min(csvData, d => d.Year) : 2000;
            const maxYear = csvData.length ? d3.max(csvData, d => d.Year) : 2025;
            const maxCubes = 100;
            const yearFraction = (year - minYear) / Math.max(1, (maxYear - minYear));
            const cubeCount = Math.max(5, Math.floor(maxCubes * (1 - yearFraction))); // fewer cubes over time

            // initialize groups if necessary and set labels using CSV values for the selected year
            // For each group, pick the corresponding species name from `groupSpecies`
            const groupValues = [];
            for (let gi = 0; gi < numGroups; gi++) {
                const species = groupSpecies[gi] || groupSpecies[0];
                const val = point ? (+point[species] || 0) : 0;
                groupValues.push(val);
            }

            // ensure materials/textures exist
            initGroups(groupValues[0] || 0);
            updateGroupLabels(groupValues.map(v => String(v)));

            createCubes(cubeCount);

            // No color-shift: keep model's own materials and textures intact.
            // We intentionally do not modify materials here so the GLTF textures/colors remain unchanged.
        }

        slider.addEventListener('input', e => {
            const year = +e.target.value;
            updateVisualization(year);
        });

        // Load CSV and initialize graph + slider
        d3.csv('data/EstimatedFishPricesByYear.csv', d => {
            // parse numeric values
            const parsed = { Year: +d.Year };
            Object.keys(d).forEach(k => {
                if (k === 'Year') return;
                parsed[k] = d[k] === undefined || d[k] === '' ? 0 : +d[k];
            });
            return parsed;
        }).then(rows => {
            csvData = rows;
            if (!csvData || csvData.length === 0) {
                console.warn('CSV loaded but empty. Keeping placeholder graph.');
                return;
            }

            // build the D3 graph now that we have data
            buildGraph(csvData);

            // set slider min/max/value from CSV year range
            const minY = d3.min(csvData, d => d.Year);
            const maxY = d3.max(csvData, d => d.Year);
            slider.min = minY;
            slider.max = maxY;
            slider.value = minY;
            // initialize visualization for starting year
            updateVisualization(+slider.value);
        }).catch(err => {
            console.error('Failed to load CSV:', err);
        });
    </script>
</body>
</html>
